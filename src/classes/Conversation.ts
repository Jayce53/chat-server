/**
 * On the server, conversation IDs are generated by joining the user IDs with a colon. The lower user ID is first.
 * i.e. 123456:654321
 */
import {db} from "@/classes/Database.js";

const enum MessageType {
  MESSAGE,
  IMAGE
}
export interface Message {
  senderId : number;
  timestamp : number;
  content : {
    type : MessageType,
    text : string
  };
}

/**
 * This is the shape of the conversation objects we send on a RELOGIN
 */
export interface WSConversation {
  partnerId : number,
  messages : Message[]
}

const conversations : Map<string, Conversation> = new Map();
const conversationIndex : Map<number, string[]> = new Map();

export class Conversation {
  _id : string;
  participants : number[];
  messages : Message[];

  private constructor(fromId : number, toId : number) {
    this._id = Conversation.makeId(fromId, toId);
    this.participants = [fromId, toId];
    this.messages = [];
  }

  /**
   * Generate a conversation ID ("id:id")from two user IDs
   * The lower ID is first
   * This should be unique (the same two user _id's can't have more than one conversation)
   * @param fromId
   * @param toId
   */
  static makeId(fromId : number, toId : number) : string {
    return fromId < toId ? `${fromId}:${toId}` : `${toId}:${fromId}`;
  }

  /**
   * Adds a conversation ID to the conversation index for each user
   * @param id1
   * @param id2
   * @param conversationId
   */
  static updateConversationIndex(id1 : number, id2 : number, conversationId : string) : void {
    [id1, id2].forEach((id : number) => {
      let convs = conversationIndex.get(id);
      if (!convs) {
        convs = [];
      }
      convs.push(conversationId);
      conversationIndex.set(id, convs);
    });
  }

  /**
   * Get or create the conversation object for two users
   *
   * If we create a new conversation, we'll also add the conversation ID to the conversationIndex
   * for each user so we can find all a user's conversation ID's from either user ID
   * @param id1
   * @param id2
   */
  static async get(id1 : number, id2 : number) : Promise<Conversation> {
    const id = Conversation.makeId(id1, id2);
    let conversation = conversations.get(id);
    if (!conversation) {
      conversation = new Conversation(id1, id2);
      conversations.set(id, conversation);
      Conversation.updateConversationIndex(id1, id2, conversation._id); // Is this necessary?
      await db.insertOne("conversation", {_id : conversation._id, participants : conversation.participants, messages : []});
    }
    return conversation;
  }


  static getByConversationId(id : string) : Conversation | undefined {
    return conversations.get(id);
  }

  /**
   * Get all the conversation for a user and then create the data for a "cv" message
   * @param userId
   */
  static getAllByUserId(userId : number) : WSConversation [] {
    /**
     * Get an array of all the Conversations for userId
     * @type {string[] | undefined}
     */
    const conversationIX : string[] | undefined = conversationIndex.get(userId);
    if (!conversationIX) {
      return [];
    }

    const thisConversations : WSConversation[] = [];
    conversationIX.forEach((conversationId : string) => {
      const conv = Conversation.getByConversationId(conversationId);
      if (!conv) {
        // FIXME - how can this happen
      } else {
        const wsConv : WSConversation = {
          partnerId : (conv.participants.filter((id) => id !== userId))[0],
          messages  : conv.messages,
        };
        thisConversations.push(wsConv);
      }
    });
    console.log(thisConversations);
    return thisConversations;
  }

  /**
   * Add a message to the conversation
   * @param senderId
   * @param newMessage
   */
  async addMessage(senderId : number, newMessage : string) : Promise<void> {
    const message : Message = {senderId, content : {type : MessageType.MESSAGE, text : newMessage}, timestamp : Date.now()};
    this.messages.push(message);

    await db.updateOne("conversation", {_id : this._id}, {$push : {messages : message}})
      .catch((err) => {
        console.error("Error inserting conversation: ", err);
        // FIXME - what now???
      });
  }

  async addImage(senderId : number, imageFile : string) : Promise<void> {
    const message : Message = {senderId, content : {type : MessageType.IMAGE, text : imageFile}, timestamp : Date.now()};
    this.messages.push(message);

    await db.updateOne("conversation", {_id : this._id}, {$push : {messages : message}})
      .catch((err) => {
        console.error("Error inserting conversation: ", err);
        // FIXME - what now???
      });
  }

  /**
   * When we get a notification of an expired user, we should remove all the conversations we have for that user
   * Just delete'ing the Conversation instance from the conversations map should release the memory
   *
   * FIXME - should we hold on to the conversation until both participants have logged out?
   * So on each conversation we remove the userId from the participants list, and if that's now zero, we delete the id in the map oand on the DB ??
   * Why would this be a good idea? Recovery?
   */
  static remove(userIds : number[]) : Promise<any> {
    userIds.forEach((userId) => {
      const convs : string[] = conversationIndex.get(userId) || [];
      convs.forEach((cnvId) => {
        conversations.delete(cnvId);
      });
      conversationIndex.delete(userId);
    });
    return db.deleteMany("conversation", {participants : {$in : userIds}});
  }
}
